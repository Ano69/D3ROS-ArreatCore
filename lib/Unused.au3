#include-once

Func LevelAreaConstants()
	Global $A1_C6_SpiderCave_01_Entrance = 0xE3A6
	Global $A1_C6_SpiderCave_01_Main = 0x132EC
	Global $A1_C6_SpiderCave_01_Queen = 0xF506
	Global $A1_Dun_Crypt_Dev_Hell = 0x36581
	Global $A1_Fields_Cave_SwordOfJustice_Level01 = 0x1D455
	Global $A1_Fields_Den = 0x21045
	Global $A1_Fields_Den_Level02 = 0x2F6b8
	Global $A1_Fields_RandomDRLG_CaveA_Level01 = 0x141C4
	Global $A1_Fields_RandomDRLG_CaveA_Level02 = 0x141C5
	Global $A1_Fields_RandomDRLG_ScavengerDenA_Level01 = 0x13D0D
	Global $A1_Fields_RandomDRLG_ScavengerDenA_Level02 = 0x13D17
	Global $A1_Fields_Vendor_Tinker_Exterior = 0x2bC0C
	Global $A1_Highlands_RandomDRLG_GoatmanCaveA_Level01 = 0x14286
	Global $A1_Highlands_RandomDRLG_GoatmanCaveA_Level02 = 0x14287
	Global $A1_Highlands_RandomDRLG_WestTower_Level01 = 0x14196
	Global $A1_Highlands_RandomDRLG_WestTower_Level02 = 0x14197
	Global $A1_Random_Level01 = 0x33A17
	Global $A1_trDun_Blacksmith_Cellar = 0x144A6
	Global $A1_trDun_ButchersLair_02 = 0x16301
	Global $A1_trDun_Cain_Intro = 0xED2A
	Global $A1_trDun_Cave_Highlands_Random01_VendorRescue = 0x21310
	Global $A1_trdun_Cave_Nephalem_01 = 0xEBEC
	Global $A1_trdun_Cave_Nephalem_02 = 0xEBED
	Global $A1_trdun_Cave_Nephalem_03 = 0xEBEE
	Global $A1_trDun_Cave_Old_Ruins_Random01 = 0x278AC
	Global $A1_trDun_CrownRoom = 0x18FDA
	Global $A1_trDun_Crypt_Event_Tower_Of_Power = 0x138F4
	Global $A1_trDun_Crypt_Flooded_Memories_Level01 = 0x18F9c
	Global $A1_trDun_Crypt_Flooded_Memories_Level02 = 0x287A6
	Global $A1_trdun_Crypt_Special_00 = 0x25BDC
	Global $A1_trdun_Crypt_Special_01 = 0xECB9
	Global $A1_trDun_Event_JarOfSouls = 0x2371E
	Global $A1_trDun_FalseSecretPassage_01 = 0x14540
	Global $A1_trDun_FalseSecretPassage_02 = 0x14541
	Global $A1_trDun_FalseSecretPassage_03 = 0x14542
	Global $A1_trDun_Jail_Level01 = 0x171d0
	Global $A1_trDun_Jail_Level01_Cells = 0x1783D
	Global $A1_trDun_Leoric01 = 0x4D3E
	Global $A1_trDun_Leoric02 = 0x4D3F
	Global $A1_trDun_Leoric03 = 0x4D40
	Global $A1_trDun_Level01 = 0x4D44
	Global $A1_trDun_Level04 = 0x4D47
	Global $A1_trDun_Level05_Templar = 0x15763
	Global $A1_trDun_Level06 = 0x4D49
	Global $A1_trDun_Level07B = 0x4D4B
	Global $A1_trDun_Level07D = 0x4D4D
	Global $A1_trDun_Tyrael_Level09 = 0x1CAA3
	Global $A1_trDun_TyraelJail = 0x24447
	Global $A1_trOut_AdriasCellar = 0xF5F8
	Global $A1_trOUT_AdriasHut = 0x4DD9
	Global $A1_trOut_BatesFarmCellar = 0x248A5
	Global $A1_trOUT_Church = 0x4DDD
	Global $A1_trOut_Fields_Vendor_Curios = 0x1A3B7
	Global $A1_trOut_Fields_Vendor_Curios_Exterior = 0x2BE7B
	Global $A1_trOUT_FishingVillage = 0x4DDF
	Global $A1_trOUT_FishingVillageHeights = 0x1FB03
	Global $A1_trOut_ForlornFarm = 0x20B72
	Global $A1_trOUT_Graveyard = 0x4DE2
	Global $A1_trOUT_Highlands = 0x4DE4
	Global $A1_trOUT_Highlands_Bridge = 0x16DC0
	Global $A1_trOut_Highlands_DunExterior_A = 0x15718
	Global $A1_trOUT_Highlands_ServantHouse_Cellar_Vendor = 0x29CD1
	Global $A1_trOUT_Highlands_Sub240_GoatmanGraveyard = 0x1F95F
	Global $A1_trOUT_Highlands2 = 0x4DE5
	Global $A1_trOUT_Highlands3 = 0x4AF
	Global $A1_trOut_Leoric_Manor_Int = 0x189F6
	Global $A1_trOUT_LeoricsManor = 0x4DE7
	Global $A1_trOut_MysticWagon = 0x20F08
	Global $A1_trOUT_NewTristram = 0x4DEB
	Global $A1_trOUT_NewTristram_AttackArea = 0x316CE
	Global $A1_trOUT_NewTristramOverlook = 0x26186
	Global $A1_trOut_Old_Tristram = 0x163FD
	Global $A1_trOut_Old_Tristram_Road = 0x164BC
	Global $A1_trOut_Old_Tristram_Road_Cath = 0x18BE7
	Global $A1_trOut_OldTristram_Cellar = 0x1A22B
	Global $A1_trOut_OldTristram_Cellar_1 = 0x1A104
	Global $A1_trOut_OldTristram_Cellar_2 = 0x1A105
	Global $A1_trOut_OldTristram_Cellar_3 = 0x19322
	Global $A1_trOut_oldTristram_TreeCave = 0x19C87
	Global $A1_trOut_Scoundrel_Event_Old_Mill_2 = 0x35556
	Global $A1_trOut_TownAttack_ChapelCellar = 0x1D43E
	Global $A1_trOut_Tristram_CainsHouse = 0x1FC73
	Global $A1_trOut_Tristram_Inn = 0x1AB91
	Global $A1_trOut_Tristram_LeahsRoom = 0x15349
	Global $A1_trOut_TristramFields_A = 0x4DF0
	Global $A1_trOut_TristramFields_B = 0x4DF1
	Global $A1_trOut_TristramFields_ExitA = 0xF085
	Global $A1_trOut_TristramFields_Forsaken_Grounds = 0x2BD6F
	Global $A1_trOut_TristramFields_Secluded_Grove = 0x2BD6E
	Global $A1_trOut_TristramWilderness = 0x4DF2
	Global $A1_trOut_TristramWilderness_SubScenes = 0x236AA
	Global $A1_trOut_Vendor_Tinker_Room = 0x19821
	Global $A1_trOut_Wilderness_BurialGrounds = 0x11C08
	Global $A1_trOut_Wilderness_CorpseHouse = 0x30ADF
	Global $A1_trOut_Wilderness_Sub80_FamilyTree = 0x236A1
	Global $A2_Belial_Room_01 = 0xED55
	Global $A2_Belial_Room_Intro = 0x13D1A
	Global $A2_c1Dun_Swr_Caldeum_01 = 0x4D4F
	Global $A2_c2dun_Zolt_TreasureHunter = 0x4D53
	Global $A2_c3Dun_Aqd_Oasis_Level01 = 0xE069
	Global $A2_cadun_Zolt_Timed01_Level01 = 0x4D52
	Global $A2_cadun_Zolt_Timed01_Level02 = 0x29108
	Global $A2_Caldeum = 0x19234
	Global $A2_Caldeum_Uprising = 0x33613
	Global $A2_caOut_Alcarnus_RandomCellar_1 = 0x245A7
	Global $A2_caOut_Alcarnus_RandomCellar_2 = 0x245A8
	Global $A2_caOut_Alcarnus_RandomCellar_3 = 0x245A9
	Global $A2_caOUT_Boneyard_01 = 0xD24A
	Global $A2_caOUT_Borderlands_Khamsin_Mine = 0xEE8A
	Global $A2_caOUT_BorderlandsKhamsin = 0xF8B2
	Global $A2_caOut_Cellar_Alcarnus_Main = 0x2FAC4
	Global $A2_caOut_CT_RefugeeCamp = 0xD811
	Global $A2_caOut_CT_RefugeeCamp_Gates = 0x318FD
	Global $A2_caOut_CT_RefugeeCamp_Hub = 0x2917A
	Global $A2_caOut_Hub_Inn = 0x2AA00
	Global $A2_caOut_Interior_C_DogBite = 0x2D7BB
	Global $A2_caOut_Interior_H_RockWorm = 0x232F5
	Global $A2_caOut_Mine_Abandoned_Cellar = 0x4D81
	Global $A2_caOut_Oasis = 0xE051
	Global $A2_caOut_Oasis_Exit = 0x2ACE2
	Global $A2_caOut_Oasis_Exit_A = 0x2AD07
	Global $A2_caOut_Oasis_Rakanishu = 0x33BDD
	Global $A2_caOut_Oasis_RandomCellar_1 = 0x27099
	Global $A2_caOut_Oasis_RandomCellar_2 = 0x2709A
	Global $A2_caOut_Oasis_RandomCellar_3 = 0x2709B
	Global $A2_caOut_Oasis_RandomCellar_4 = 0x27bE7
	Global $A2_caOut_Oasis1_Water = 0xE664
	Global $A2_caOut_Oasis2 = 0xE058
	Global $A2_caOut_OasisCellars = 0x1B100
	Global $A2_caOUT_StingingWinds = 0x4D7F
	Global $A2_caOUT_StingingWinds_Alcarnus_Tier1 = 0x4D71
	Global $A2_caOUT_StingingWinds_Alcarnus_Tier2 = 0x4D72
	Global $A2_caOUT_StingingWinds_Bridge = 0x29886
	Global $A2_caOUT_StingingWinds_Canyon = 0x4D7C
	Global $A2_caOUT_StingingWinds_FallenCamp01 = 0x288EF
	Global $A2_caOUT_StingingWinds_PostBridge = 0x4D7E
	Global $A2_caOUT_StingingWinds_PreAlcarnus = 0x4D7B
	Global $A2_caOUT_StingingWinds_PreBridge = 0x4D7D
	Global $A2_caOut_Stranded2 = 0x1DA4A
	Global $A2_caOut_ZakarwaMerchantCellar = 0x1BEBB
	Global $A2_Cave_Random01 = 0x26F64
	Global $A2_Cave_Random01_Level02 = 0x35E85
	Global $A2_CultistCellarEast = 0x19218
	Global $A2_CultistCellarWest = 0x19214
	Global $A2_dun_Aqd_Control_A = 0xF9F3
	Global $A2_dun_Aqd_Control_B = 0xF9F4
	Global $A2_dun_Aqd_Oasis_RandomFacePuzzle_Large = 0x26B82
	Global $A2_dun_Aqd_Oasis_RandomFacePuzzle_Small = 0x26AB0
	Global $A2_dun_Aqd_Special_01 = 0xF520
	Global $A2_dun_Aqd_Special_A = 0xF53A
	Global $A2_dun_Aqd_Special_B = 0xF53C
	Global $A2_Dun_Aqd_Swr_to_Oasis_Level01 = 0x23D96
	Global $A2_dun_Cave_BloodVial_01 = 0x31F55
	Global $A2_dun_Cave_BloodVial_02 = 0x31F83
	Global $A2_dun_Oasis_Cave_MapDungeon = 0x29616
	Global $A2_dun_Oasis_Cave_MapDungeon_Level02 = 0x2F6bF
	Global $A2_dun_PortalRoulette_A = 0x1B37F
	Global $A2_Dun_Swr_Adria_Level01 = 0xE47E
	Global $A2_Dun_Swr_Caldeum_Sewers_01 = 0x1B205
	Global $A2_dun_Zolt_Blood02_Level01_Part1 = 0x1E12E
	Global $A2_dun_Zolt_Blood02_Level01_Part2 = 0x25872
	Global $A2_Dun_Zolt_BossFight_Level04 = 0xEB22
	Global $A2_dun_Zolt_Head_Random01 = 0xF0C0
	Global $A2_Dun_Zolt_Level01 = 0x4D55
	Global $A2_Dun_Zolt_Level02 = 0x4D56
	Global $A2_Dun_Zolt_Level03 = 0x4D57
	Global $A2_Dun_Zolt_Lobby = 0x4D58
	Global $A2_Dun_Zolt_LobbyCenter = 0x2AFBA
	Global $A2_Dun_Zolt_Random_Level01 = 0x4D59
	Global $A2_Dun_Zolt_Random_Level02 = 0x36571
	Global $A2_dun_Zolt_Random_PortalRoulette_02 = 0x2FDCF
	Global $A2_Dun_Zolt_ShadowRealm_Level01 = 0x13AD0
	Global $A2_Event_DyingManMine = 0x2270B
	Global $A2_Event_PriceOfMercy_Cellar = 0x2FD9E
	Global $A2_Rockworm_Cellar_Cave = 0x2FE81
	Global $A2_trDun_Boneyard_Spider_Cave_01 = 0x1B437
	Global $A2_trDun_Boneyard_Spider_Cave_02 = 0x35758
	Global $A2_trDun_Boneyard_Worm_Cave_01 = 0x1B433
	Global $A2_trDun_Boneyard_Worm_Cave_02 = 0x35759
	Global $A2_trDun_Cave_Oasis_Random01 = 0xF46F
	Global $A2_trDun_Cave_Oasis_Random01_Level02 = 0x2F6C2
	Global $A2_trDun_Cave_Oasis_Random02 = 0xF46E
	Global $A2_trDun_Cave_Oasis_Random02_Level02 = 0x27551
	Global $A2_dun_Aqd_Oasis_Level00 = 0x2F0B6
	Global $A2_dun_Aqd_Oasis_Level01 = 0x2F0B1
	Global $A3_AzmodanFight = 0x1B39C
	Global $A3_Battlefield_A = 0x1B7A4
	Global $A3_Battlefield_B = 0x1B7B5
	Global $A3_Battlefield_C = 0x1B7C4
	Global $A3_Bridge_01 = 0x10F80
	Global $A3_Bridge_Choke_A = 0x25DA8
	Global $A3_Dun_Battlefield_Gate = 0x25C14
	Global $A3_dun_Bridge_Interior_Random01 = 0x224ad
	Global $A3_dun_Bridge_Interior_Random02 = 0x32270
	Global $A3_Dun_Crater_Level_01 = 0x15040
	Global $A3_Dun_Crater_Level_02 = 0x1d209
	Global $A3_Dun_Crater_Level_03 = 0x1d20a
	Global $A3_dun_Crater_ST_Level01 = 0x13b97
	Global $A3_dun_Crater_ST_Level01B = 0x1d365
	Global $A3_dun_Crater_ST_Level02 = 0x13b98
	Global $A3_dun_Crater_ST_Level02B = 0x2200a
	Global $A3_dun_Crater_ST_Level04 = 0x14cd2
	Global $A3_dun_Crater_ST_Level04B = 0x1d368
	Global $A3_dun_IceCaves_Random_01 = 0x2e3a1
	Global $A3_dun_IceCaves_Random_01_Level_02 = 0x36206
	Global $A3_dun_IceCaves_Timed_01 = 0x2ea66
	Global $A3_dun_IceCaves_Timed_01_Level_02 = 0x36207
	Global $A3_Dun_Keep_Hub = 0x16b11
	Global $A3_Dun_Keep_Hub_Inn = 0x2d38c
	Global $A3_Dun_Keep_Level03 = 0x126ac
	Global $A3_Dun_Keep_Level04 = 0x16baf
	Global $A3_Dun_Keep_Level05 = 0x21500
	Global $A3_Dun_Keep_Random_01 = 0x2aa4a
	Global $A3_Dun_Keep_Random_01_Level_02 = 0x36238
	Global $A3_Dun_Keep_Random_02 = 0x2c7f2
	Global $A3_Dun_Keep_Random_02_Level_02 = 0x36239
	Global $A3_Dun_Keep_Random_03 = 0x2c802
	Global $A3_Dun_Keep_Random_03_Level_02 = 0x3623a
	Global $A3_Dun_Keep_Random_04 = 0x2c8e6
	Global $A3_Dun_Keep_Random_04_Level_02 = 0x36241
	Global $A3_Dun_Keep_Random_Cellar_01 = 0x35ee9
	Global $A3_Dun_Keep_Random_Cellar_02 = 0x35ee8
	Global $A3_Dun_Keep_Random_Cellar_03 = 0x303f7
	Global $A3_Dun_Keep_TheBreach_Level04 = 0x3558f
	Global $A3_dun_rmpt_Level01 = 0x16b20
	Global $A3_dun_rmpt_Level02 = 0x16bf5
	Global $A3_Gluttony_Boss = 0x1b280
	Global $A3_dun_Hub_Adria_Tower = 0x31222
	Global $A3_dun_hub_AdriaTower_Intro_01 = 0x3253e
	Global $A4_dun_Diablo_Arena = 0x1abfb
	Global $A4_dun_Diablo_Arena_Phase3 = 0x348c3
	Global $A4_dun_Garden_of_Hope_01 = 0x1abca
	Global $A4_dun_Garden_of_Hope_02 = 0x1abcc
	Global $A4_dun_Garden3_SpireEntrance = 0x1d44a
	Global $A4_dun_Heaven_1000_Monsters_Fight = 0x1aa5d
	Global $A4_dun_Heaven_1000_Monsters_Fight_Entrance = 0x2f169
	Global $A4_dun_Hell_Portal_01 = 0x1abd6
	Global $A4_dun_Hell_Portal_02 = 0x1abdb
	Global $A4_Dun_Keep_Hub = 0x301ed
	Global $A4_dun_LibraryOfFate = 0x23120
	Global $A4_dun_Spire_00 = 0x307a4
	Global $A4_dun_Spire_01 = 0x1abe2
	Global $A4_dun_Spire_02 = 0x1abe4
	Global $A4_dun_Spire_03 = 0x1abe6
	Global $A4_dun_Spire_04 = 0x33728
	Global $A4_dun_Spire_SigilRoom_A = 0x313c4
	Global $A4_dun_Spire_SigilRoom_B = 0x2ae7a
	Global $A4_dun_Spire_SigilRoom_C = 0x313c6
	Global $A4_dun_Spire_SigilRoom_D = 0x313c7
	Global $A4_dun_Diablo_ShadowRealm_01 = 0x25845
	Global $A4_dun_spire_DiabloEntrance = 0x3227a
	Global $A4_dun_spire_exterior = 0x34964
	Global $Axe_Bad_Data = 0x4d60
	Global $PvP_Maze_01 = 0x4da2
	Global $PvP_Octogon_01 = 0x4da3
	Global $PvP_Pillar_01 = 0x4da4
	Global $PvP_Stairs_01 = 0x4da5
	Global $PvP_Test_BlueTeam = 0x4da6
	Global $PvP_Test_Neutral = 0x4da7
	Global $PvP_Test_RedTeam = 0x4da8
	Global $PvPArena = 0x4d9c
EndFunc   ;==>LevelAreaConstants

Func handle_banlist($coords_ban)
	If StringInStr($handle_banlist1, $coords_ban) = false Then
		_log("banlist 1 -> " & $coords_ban)
		$handle_banlist1 = $handle_banlist1 & "|" & $coords_ban
	ElseIf StringInStr($handle_banlist1, $coords_ban)  And StringInStr($handle_banlist2, $coords_ban) = false Then
		_log("banlist 2 -> " & $coords_ban)
		$handle_banlist2 = $handle_banlist2 & "|" & $coords_ban
	ElseIf StringInStr($handle_banlist2, $coords_ban)  Then
		_log("banlist def -> " & $coords_ban)
		$handle_banlistdef = $handle_banlistdef & "|" & $coords_ban
	 EndIf
	 				_log("banlist 1 -> " & $handle_banlist1)

				_log("banlist 2 -> " & $handle_banlist2)

			_log("banlist def -> " & $handle_banlistdef)

EndFunc   ;==>handle_banlist

Func xml_to_item($name, $stats)
	$rules_name = "(?i){c:[a-z0-9]*}([a-z0-9éèêëîïìâàäûüùöôòÿ" & @CRLF & " \+ \% \- \’ \' ]*){/c}"
	$rules_stats = "(?i){c:[a-z0-9]*}([a-z0-9éèêëîïìâàäûüùöôòÿ" & @CRLF & " \+ \% \- \’ \' ]*){/c}"
	;$rules_stat = "(?i){c:[a-z1-9]*}(.*){/c}"
	$str = "<item>" & @CRLF
	If StringRegExp($name, $rules_name) = 1 Then ;patern declaration ilvl
		$name_item = StringRegExp($name, $rules_name, 2)
		;MsgBox(1, "", $name_item[1])
		$name = "<name>" & $name_item[1] & "</name>" & @CRLF
	EndIf

	If StringRegExp($stats, $rules_stats) = 1 Then
		$stats_item = StringRegExp($stats, $rules_stats, 3)
		;_ArrayDisplay($stats_item)
		$temp_stats = ""
		For $i = 0 To UBound($stats_item) - 1
			$temp_stats = $temp_stats & "<stats>- " & $stats_item[$i] & "</stats>" & @CRLF

		Next
	EndIf
	$str = $str & $name & $temp_stats & "</item>" & @CRLF & @CRLF
	Return $str
EndFunc   ;==>xml_to_item

Func Xml_To_Str($str, $load_file)
	Local $file = FileOpen($load_file, 1)
	If $file = -1 Then
		MsgBox(0, "Error", "Unable to open xml file : " & $load_file)
		Exit

	EndIf
	FileWrite($file, $str)
	FileClose($file)
EndFunc   ;==>Xml_To_Str


Func Ftp_Upload_To_Xml($file)
	If Not $ftpserver = "" And Not $ftpusername = "" And Not $ftppass = "" Then
		$Open = _FTPOpen('MyFTP Control')
		$Conn = _FTPConnect($Open, $ftpserver, $ftpusername, $ftppass)
		$Ftpp = _FtpPutFile($Conn, $file, "statistique_D3/" & $file)
		$Ftpc = _FTPClose($Open)
	EndIf
EndFunc   ;==>Ftp_Upload_To_Xml
;;--------------------------------------------------------------------------------
;;     Find Difficulty from vendor
;;	   Get vendor Level and deduce game difficulty from it
;;		$GameDifficulty = not yet determined, 1 = Norm, 2 = Nm, 3 = Hell, 4 = Inferno
;;--------------------------------------------------------------------------------
Func GetDifficulty()
	If $GameDifficulty = 0 Then

		Local $index, $offset, $count, $item[4]
		startIterateLocalActor($index, $offset, $count)
		While iterateLocalActorList($index, $offset, $count, $item)
			If StringInStr($item[1], $RepairVendor) Then
				Global $npclevel = IterateActorAtribs($item[0], $Atrib_Level)

				Switch $npclevel
					Case 1 To 59
						Global $GameDifficulty = 1
					Case 60 To 70
						Global $GameDifficulty = 4
				EndSwitch

				ExitLoop
			EndIf
		WEnd
		_log("Game Difficulty is : " & $GameDifficulty)
	EndIf
EndFunc   ;==>GetDifficulty

;;--------------------------------------------------------------------------------
; Function:			GetPackItemLevel($ACD, $_REQ)
;;--------------------------------------------------------------------------------
Func GetPackItemLevel($ACD, $_REQ)
	;IterateLocalActor()
	;$ACDIndex = _ArraySearch($__ACTOR, "0x" & Hex($_guid), 0, 0, 0, 1, 1, 1) ;this bitch is slow as hell
	If $ACD = -1 Then Return False
	$_Count = _MemoryRead($_ActorAtrib_Count, $d3, 'int')
	If $_Count > 500 Then
		_log("Attention la valeur de Count était de " & $_Count)
		$_Count = 500
	EndIf

	$CurrentOffset = $_ActorAtrib_4
	Dim $ACTORatrib
	For $i = 0 To $_Count
		$ACTORatrib = _MemoryRead($CurrentOffset, $d3, 'ptr')
		If $ACTORatrib = $ACD Then
			$test = _MemoryRead($CurrentOffset + 0x10, $d3, 'ptr')
			$CurretOffset = $test
			For $i = 0 To 825
				$data = _MemoryRead($CurretOffset, $d3, 'ptr')
				$CurretOffset = $CurretOffset + 0x4
				If $data <> 0x0 Then
					$AtribData = _MemoryRead($data + 0x4, $d3, 'ptr')
					If StringLeft($AtribData, 7) = "0x0003B" Then
						;_log("Debug :" &$data+0x4 & " : " & _MemoryRead($data+0x4, $d3, 'int') ) ;FOR DEBUGGING
						If "0x" & StringRight($AtribData, 3) = $_REQ[0] Then
							Return _MemoryRead($data + 0x8, $d3, $_REQ[1])
						EndIf
					EndIf
					If StringLeft($AtribData, 7) = "0xFFFFF" Then
						;_log("Debug :" &$data+0x4 & " : " & _MemoryRead($data+0x4, $d3, 'int') ) ;FOR DEBUGGING
						If "0x" & StringRight($AtribData, 3) = $_REQ[0] Then
							Return _MemoryRead($data + 0x8, $d3, $_REQ[1])
						EndIf
					EndIf
				EndIf
			Next
			Return False
		EndIf
		$CurrentOffset = $CurrentOffset + $ofs_ActorAtrib_StrucSize
	Next
	Return False
EndFunc   ;==>GetPackItemLevel

;;--------------------------------------------------------------------------------
;;	Getting Backpack Item Info, extended to show some more info
;;  $bag = 0 for backpack and 15 for stash
;;--------------------------------------------------------------------------------
Func IterateBackpackExtendedWithLvl($bag = 0)
	$list = IndexSNO($gameBalance)
	$armorOffs = 0
	$weaponOffs = 0
	$otherOffs = 0
	For $j = 0 To UBound($list) - 1
		;19750 = armor, 19754 = weapon, 1953 = other
		If ($list[$j][1] = 19750) Then
			$armorOffs = $list[$j][0]
		EndIf
		If ($list[$j][1] = 19754) Then
			$weaponOffs = $list[$j][0]
		EndIf
		If ($list[$j][1] = 19753) Then
			$otherOffs = $list[$j][0]
		EndIf
	Next
	Local $armorItems = GetLevels($armorOffs)
	Local $weaponItems = GetLevels($weaponOffs)
	Local $otherItems = GetLevels($otherOffs)
	Local $data = IterateBackpack($bag)
	Local $armorItemsWithLvl = MapItemWithLvl($data, $armorItems, 8)
	Local $weaponItemsWithLvl = MapItemWithLvl($data, $weaponItems, 8)
	Local $otherItemsWithLvl = MapItemWithLvl($data, $otherItems, 8)
	Local $allItems[UBound($armorItemsWithLvl, 1)][UBound($armorItemsWithLvl, 2)]
	For $i = 0 To UBound($allItems) - 1 Step 1
		If $armorItemsWithLvl[$i][9] <> "" Then
			;copy from $armorItemsWithLvl to all items
			For $j = 0 To UBound($armorItemsWithLvl, 2) - 1 Step 1
				$allItems[$i][$j] = $armorItemsWithLvl[$i][$j]
			Next
		ElseIf $weaponItemsWithLvl[$i][9] <> "" Then
			;copy from $weaponItemsWithLvl to all items
			For $j = 0 To UBound($weaponItemsWithLvl, 2) - 1 Step 1
				$allItems[$i][$j] = $weaponItemsWithLvl[$i][$j]
			Next
		ElseIf $otherItemsWithLvl[$i][9] <> "" Then
			;copy from $otherItemsWithLvl to all items
			For $j = 0 To UBound($otherItemsWithLvl, 2) - 1 Step 1
				$allItems[$i][$j] = $otherItemsWithLvl[$i][$j]
			Next
		EndIf
	Next
	Return $allItems
EndFunc   ;==>IterateBackpackExtendedWithLvl


;;--------------------------------------------------------------------------------
;;	Maps snos containg a lvl to the item with that snoid
;;--------------------------------------------------------------------------------
Func MapItemWithLvl($items, $snowithlvl, $indexForBGID)
	Local $newItems = $items
	ReDim $newItems[UBound($items, 1)][UBound($items, 2) + UBound($snowithlvl, 2) + 9] ;add size for some new variables
	For $i = 0 To UBound($items) - 1 Step 1
		For $j = 0 To UBound($snowithlvl) - 1 Step 1
			If $snowithlvl[$j][0] = $items[$i][$indexForBGID] Then
				$newItems[$i][$indexForBGID + 1] = $snowithlvl[$j][1] ;ilvl
				$newItems[$i][$indexForBGID + 2] = $snowithlvl[$j][2] ;min dmg
				$newItems[$i][$indexForBGID + 3] = $snowithlvl[$j][3] ;;max dmg
				$newItems[$i][$indexForBGID + 4] = $snowithlvl[$j][4] ;;min armor
				$newItems[$i][$indexForBGID + 5] = $snowithlvl[$j][5] ;max armor
				$newItems[$i][$indexForBGID + 6] = $snowithlvl[$j][6] ;min dmg modifier
				$newItems[$i][$indexForBGID + 7] = $snowithlvl[$j][7] ;max dmg modifier
				$newItems[$i][$indexForBGID + 8] = $snowithlvl[$j][8] ;gold
				$newItems[$i][$indexForBGID + 9] = $snowithlvl[$j][9] ;weapon speed
				;;some extra attributes
				$newItems[$i][$indexForBGID + 10] = IterateActorAtribs($newItems[$i][0], $Atrib_Item_Quality_Level) ;quality lvl
				$newItems[$i][$indexForBGID + 11] = IterateActorAtribs($newItems[$i][0], $Atrib_Strength_Item) ;str
				$newItems[$i][$indexForBGID + 12] = IterateActorAtribs($newItems[$i][0], $Atrib_Vitality_Item) ;vit
				$newItems[$i][$indexForBGID + 12] = IterateActorAtribs($newItems[$i][0], $Atrib_Intelligence_Item) ;int
				$newItems[$i][$indexForBGID + 13] = IterateActorAtribs($newItems[$i][0], $Atrib_Dexterity_Item) ;dex
				$newItems[$i][$indexForBGID + 15] = IterateActorAtribs($newItems[$i][0], $Atrib_Resistance_All) ;all res
				$newItems[$i][$indexForBGID + 16] = Round(IterateActorAtribs($newItems[$i][0], $Atrib_Gold_Find) * 100) ;gf in %
				$newItems[$i][$indexForBGID + 17] = Round(IterateActorAtribs($newItems[$i][0], $Atrib_Magic_Find) * 100) ;mf in %
				$newItems[$i][$indexForBGID + 18] = Round(IterateActorAtribs($newItems[$i][0], $Atrib_Hitpoints_Max_Percent_Bonus_Item) * 100) ;life %
				$newItems[$i][$indexForBGID + 19] = _MemoryRead($newItems[$i][7] + 0x164, $d3, 'int') > 0 ;0ffset + 164 ;true=unid, false=identified
				ExitLoop
			EndIf
		Next
	Next
	Return $newItems
EndFunc   ;==>MapItemWithLvl

;;--------------------------------------------------------------------------------
;;      SkipDialog()
;;--------------------------------------------------------------------------------
Func SkipDialog($_Count)
	For $i = 1 To $_Count
		Send($KeyCloseWindows)
		Sleep(100)
	Next
EndFunc   ;==>SkipDialog

;;--------------------------------------------------------------------------------
; Functions:                     mesurestart() mesureend()
; Description:    Mesurer...
;;--------------------------------------------------------------------------------
Func mesureStart()
	Global $mesuredebug = TimerInit() ;;;;;;;;;;;;;;
	$init = TimerInit()
EndFunc   ;==>mesureStart

Func mesureEnd($nom)
	Local $difmesuredebug = TimerDiff($mesuredebug) ;;;;;;;;;;;;;
	_log("Mesure " & $nom & " : " & $difmesuredebug) ;FOR DEBUGGING;;;;;;;;;;;;
EndFunc   ;==>mesureEnd


;;--------------------------------------------------------------------------------
;;   TakeWP()
;;--------------------------------------------------------------------------------
Func TakeWP($tarChapter, $tarNum, $curChapter, $curNum)
	If $GameFailed = 0 Then
		Local $Waypoint = ""
		While Not offsetlist()
			Sleep(10)
		WEnd

		;*******************************************************
		Local $index, $offset, $count, $item[10], $maxRange = 80
		startIterateObjectsList($index, $offset, $count)
		While iterateObjectsList($index, $offset, $count, $item)
			If (StringInStr($item[1], "waypoint_arrival_ribbonGeo") And $item[9] < $maxRange) Or (StringInStr($item[1], "waypoint_neutral_ringGlow") And $item[9] < $maxRange) Or (StringInStr($item[1], "waypoint_neutral_ringGlow") And $item[9] < $maxRange) Then
				If StringInStr($item[1], "waypoint_arrival_ribbonGeo") Then
					$Waypoint = "waypoint_arrival_ribbonGeo"
				ElseIf StringInStr($item[1], "waypoint_neutral_ringGlow") Then
					$Waypoint = "waypoint_neutral_ringGlow"
				Else
					$Waypoint = "Waypoint_Town"
				EndIf
				ExitLoop
			EndIf
		WEnd

		If $Waypoint = "" Then
			$Waypoint = "waypoint"
		EndIf
		;******************************************************

		;******************************************************

		If $Waypoint = "waypoint" Then ;WAYPOINT PAR DEFAUT ON a PAS TROUVER ITEM
			_log("enclenchement Old waypoint")
			InteractByActorName($Waypoint)
			Sleep(350)
			Local $wptry = 0
			While _checkWPopen() = False And _playerdead() = False
				If $wptry <= 6 Then
					_log('Fail to open wp')
					$wptry = $wptry + 1
					InteractByActorName($Waypoint)
				EndIf
				If $wptry > 6 Then
					$GameFailed = 1
					_log('Failed to open wp after 6 try')
					ExitLoop
				EndIf
			WEnd

		Else ;WAYPOINT DEFINIT, ON A ITEM
			_log("enclechement new waypoint")
			OpenWp($item)
			Sleep(350)
			Local $wptry = 0
			While _checkWPopen() = False And _playerdead() = False
				If $wptry <= 6 Then
					_log('Fail to open wp')
					$wptry = $wptry + 1
					OpenWp($item)
				EndIf
				If $wptry > 6 Then
					$GameFailed = 1
					_log('Failed to open wp after 6 try')
					ExitLoop
				EndIf
			WEnd

		EndIf


		If $tarChapter <> $curChapter Or ($tarChapter = $curChapter And $tarChapter < $curChapter) Then
			For $i = 0 To $tarChapter - 1
				$coord = UiRatio(35, 100 + ($i * 12.5))
				MouseClick("left", $coord[0], $coord[1], 1, 3) ; Close chapters
			Next
			$coord = UiRatio(145, 100 + ($tarChapter * 12.5) + 23 + ($tarNum * 32))
			MouseClick("left", $coord[0], $coord[1], 1, 3) ; Click wp
		EndIf
		If $tarChapter = $curChapter And $tarChapter > $curChapter Then
			For $i = 0 To $tarChapter - 1
				$coord = UiRatio(35, 100 + ($i * 12.5))
				MouseClick("left", $coord[0], $coord[1], 1, 3) ; Close chapters
			Next
			$coord = UiRatio(145, 100 + ($tarChapter * 12.5) + 23 + 12 + ($tarNum * 32))
			MouseClick("left", $coord[0], $coord[1], 1, 3) ; Click wp
		EndIf
		Sleep(1500)

		While Not offsetlist()
			Sleep(10)
		WEnd
		$SkippedMove = 0 ;reset ouur skipped move count cuz we should be in brand new area
	EndIf
EndFunc   ;==>TakeWP

;;--------------------------------------------------------------------------------
;;	Gets levels from Gamebalance file, returns a list with snoid and lvl
;;--------------------------------------------------------------------------------
Func GetLevels($offset)
	If $offset <> 0 Then
		$ofs = $offset + 0x218;
		$read = _MemoryRead($ofs, $d3, 'int')
		While $read = 0
			$ofs += 0x4
			$read = _MemoryRead($ofs, $d3, 'int')
		WEnd
		$size = _MemoryRead($ofs + 0x4, $d3, 'int')
		$size -= 0x5F8
		$ofs = $offset + _MemoryRead($ofs, $d3, 'int')
		$nr = $size / 0x5F8
		Local $snoItems[$nr + 1][10]
		$j = 0
		For $i = 0 To $size Step 0x5F8
			$ofs_address = $ofs + $i
			$snoItems[$j][0] = _MemoryRead($ofs_address, $d3, 'ptr')
			$snoItems[$j][1] = _MemoryRead($ofs_address + 0x114, $d3, 'int') ;lvl
			$snoItems[$j][2] = _MemoryRead($ofs_address + 0x1C8, $d3, 'float') ;min dmg
			$snoItems[$j][3] = $snoItems[$j][2] + _MemoryRead($ofs_address + 0x1CC, $d3, 'float') ;max dmg
			$snoItems[$j][4] = _MemoryRead($ofs_address + 0x224, $d3, 'float') ;min armor
			$snoItems[$j][5] = $snoItems[$j][4] + _MemoryRead($ofs_address + 0x228, $d3, 'float') ;max armor
			$snoItems[$j][6] = _MemoryRead($ofs_address + 0x32C, $d3, 'float') ;min dmg modifier
			$snoItems[$j][7] = $snoItems[$j][4] + _MemoryRead($ofs_address + 0x330, $d3, 'float') ;max dmg modifier
			$snoItems[$j][8] = _MemoryRead($ofs_address + 0x12C, $d3, 'int') ;gold price
			$snoItems[$j][9] = _MemoryRead($ofs_address + 0x2D4, $d3, 'float') ;wpn speed
			$j += 1
		Next
	EndIf
	Return $snoItems
EndFunc   ;==>GetLevels


#cs
Func GetLocalPlayer()
	Global $ObjManStorage = 0x7CC ;0x794
	$v0 = _MemoryRead(_MemoryRead($ofs_objectmanager, $d3, 'int') + 0x984, $d3, 'int') ;0x94C/934
	$v1 = _MemoryRead(_MemoryRead($ofs_objectmanager, $d3, 'int') + $ObjManStorage + 0xA8, $d3, 'int')

	if $v0 <> 0 AND _MemoryRead($v0, $d3, 'int') <> -1 AND $v1 <> 0 Then
		return 0x8008 * _MemoryRead($v0, $d3, 'int') + $v1 + 0x58
	Else
		return 0
	EndIf
EndFunc
#ce

#cs
Func IterateFilterAffix()
        Local $index, $offset, $count, $item[10]
        startIterateObjectsList($index, $offset, $count)
        Dim $item_affix_2D[1][11]
        Local $i = 0
	    $pv_affix=getlifep()
        $compt = 0
;~ 		 $ii=0
        While iterateObjectsList($index, $offset, $count, $item)
			$compt += 1
			If Is_Affix($item,$pv_affix)  Then
			   ReDim $item_affix_2D[$i + 1][11]
			   For $x = 0 To 9
				  $item_affix_2D[$i][$x] = $item[$x]
			   Next

			   if StringInStr($item[1],"molten_trail") then $item_affix_2D[$i][10] = $range_lave
			   if (StringInStr($item[1],"woodWraith_explosion") or StringInStr($item[1],"WoodWraith_sporeCloud_emitter") ) then  $item_affix_2D[$i][10] = $range_ice
			   if StringInStr($item[1],"sandwasp_projectile") then $item_affix_2D[$i][10] = $range_arcane
			   if StringInStr($item[1],"Desecrator") then $item_affix_2D[$i][10] = $range_profa
			   if (StringInStr($item[1],"bomb_buildup") or StringInStr($item[1],"Icecluster") or stringinstr($item[1],"Molten_deathExplosion") or stringinstr($item[1],"Molten_deathStart")) then  $item_affix_2D[$i][10] = $range_ice
			   if (StringInStr($item[1],"demonmine_C") or StringInStr($item[1],"Crater_DemonClawBomb")) then $item_affix_2D[$i][10] = $range_mine
			   if StringInStr($item[1],"creepMobArm") then $item_affix_2D[$i][10] = $range_arm
			   if (StringInStr($item[1],"spore") or StringInStr($item[1],"Plagued_endCloud") or StringInStr($item[1],"Poison")) then $item_affix_2D[$i][10] = $range_peste
			   if StringInStr($item[1],"ArcaneEnchanted_petsweep") then $item_affix_2D[$i][10] = $range_arcane
			   if StringInStr($item[1],"frozenPulse") then $item_affix_2D[$i][10] = $range_arcane;pacth 8.2 e

;~ 			   if $item_affix_2D[$i][10]-$item_affix_2D[$i][9]>0 then $ii=$ii+1

			   $i += 1
			EndIf
        WEnd
;~  or $ii=0
        If $i = 0 Then
                Return False
        Else

                _ArraySort($item_affix_2D, 0, 0, 0, 9)

                Return $item_affix_2D
        EndIf
 EndFunc   ;==>IterateFilterAffix
#ce

Func GameState()
	;1 // In Game
	;0 // Loading Screen
	;5 // Menu
	;return _memoryRead(_memoryRead($ObjManStorage ,$d3, "ptr") + 0x900, $d3, "ptr")
Endfunc

;~ Func getGold() ; Fonction qui mesure l'or
;~         IterateLocalActor()
;~         $foundobject = 0
;~         For  $i = 0 To UBound ( $__ACTOR ,1 )-1
;~                 If StringInStr($__ACTOR[$i][2],"GoldCoin-") Then
;~                         return IterateActorAtribs( $__ACTOR[$i][1],$Atrib_ItemStackQuantityLo)
;~                         ExitLoop
;~                 EndIf
;~         Next
;~         Return 0
;~ EndFunc

;;--------------------------------------------------------------------------------
;;     Adapt repair tab aaccording to MP act and diff
;;--------------------------------------------------------------------------------
#cs
Func GetRepairTab()
	GetMonsterPow2()
	GetDifficulty()
	GetAct()

	If $MP > 0 And $GameDifficulty = 4 Then
		Switch $Act
			Case 1
				Global $RepairTab = 2
			Case 2 To 4
				Global $RepairTab = 3
		EndSwitch
	Else
		Switch $Act
			Case 1
				Global $RepairTab = 2
			Case 2 To 4
				Global $RepairTab = 3
		EndSwitch

	EndIf
	_log("RepairTab : " & $RepairTab & " ---> MP : " & $MP & " GameDiff : " & $GameDifficulty)

EndFunc   ;==>GetRepairTab
#ce

;;--------------------------------------------------------------------------------
;;     Find MonsterPower
;;	   Get it Via UI element
;;
;;--------------------------------------------------------------------------------
#cs
Func GetMonsterPow2()

	$GetMonsterPow2 = fastCheckuiValue('Root.NormalLayer.minimap_dialog_backgroundScreen.minimap_dialog_pve.clock', 1, 28)
	$asMpResult = StringRegExp($GetMonsterPow2, '(\()([0-9]{1,2})(\))', 1)
	If @error == 0 Then
		$MP = Number($asMpResult[1])
	Else
		$MP = 0
	EndIf
	_log("Power monster : " & $MP)
	;_log("Power monster : " & $GetMonsterPow2)
EndFunc   ;==>GetMonsterPow2
#ce

;;--------------------------------------------------------------------------------
;;      Stop()
;;--------------------------------------------------------------------------------
Func Stop()
	Exit
EndFunc   ;==>Stop

;;--------------------------------------------------------------------------------
;;      IterateAllObjectList()
;; 		Description:		Iterate object even if they dont have guid, also provide true names
;;--------------------------------------------------------------------------------
#cs
Func IterateAllObjectList($_displayInfo)
	If $_displayInfo = 1 Then _log("-----Iterating through Actors------")
	If $_displayInfo = 1 Then _log("First Actor located at: " & $_itrObjectManagerD )
	$_CurOffset = $_itrObjectManagerD
	$_Count = _MemoryRead($_itrObjectManagerCount, $d3, 'int')
	Dim $OBJ[$_Count + 1][10]
	If $_displayInfo = 1 Then _log("Number of Actors : " & $_Count )
	For $i = 0 To $_Count Step +1
		$_GUID = _MemoryRead($_CurOffset + 0x4, $d3, 'ptr')
		$_NAME = _MemoryRead($_CurOffset + 0x8, $d3, 'char[64]')
		$_POS_X = _MemoryRead($_CurOffset + 0xB0, $d3, 'float')
		$_POS_Y = _MemoryRead($_CurOffset + 0xB4, $d3, 'float')
		$_POS_Z = _MemoryRead($_CurOffset + 0xB8, $d3, 'float')
		$_DATA = _MemoryRead($_CurOffset + 0x200, $d3, 'int')
		$_DATA2 = _MemoryRead($_CurOffset + 0x1D0, $d3, 'int')
		$_DATA3 = _MemoryRead($_CurOffset + 0x1C4, $d3, 'int')
		$CurrentLoc = GetCurrentPos()
		$xd = $_POS_X - $CurrentLoc[0]
		$yd = $_POS_Y - $CurrentLoc[1]
		$zd = $_POS_Z - $CurrentLoc[2]
		$Distance = Sqrt($xd * $xd + $yd * $yd + $zd * $zd)
		$OBJ[$i][0] = $i
		$OBJ[$i][1] = $_GUID
		$OBJ[$i][2] = $_NAME
		$OBJ[$i][3] = $_POS_X
		$OBJ[$i][4] = $_POS_Y
		$OBJ[$i][5] = $_POS_Z
		$OBJ[$i][6] = $_DATA
		$OBJ[$i][7] = $_DATA2
		$OBJ[$i][8] = $Distance
		$OBJ[$i][9] = $_CurOffset
		If $_displayInfo = 1 Then _log($i & @TAB & " : " & $_CurOffset & " " & $_GUID & " : " & $_DATA & " " & $_DATA2 & " " & @TAB & $_POS_X & " " & $_POS_Y & " " & $_POS_Z & " Dist: " & $Distance & @TAB & $_NAME & " data3: " & $_DATA3 )
		;if $_displayINFO = 1 then _log($i & @TAB&" : " & $_POS_X & @TAB& $_POS_Y & @TAB & $_POS_Z & @TAB& $_NAME)
		$_CurOffset = $_CurOffset + $_ObjmanagerStrucSize
	Next
	Return $OBJ
EndFunc   ;==>IterateAllObjectList
#ce


;;--------------------------------------------------------------------------------
;;      GetCurrentPos()
;;--------------------------------------------------------------------------------
#cs
Func GetCurrentPos()
	;	Local $mesurepos = TimerInit() ;;;;;;;;;;;;;;
	Dim $return[3]

	$return[0] = _MemoryRead($_Myoffset + 0x0A4, $d3, 'float')
	$return[1] = _MemoryRead($_Myoffset + 0x0A8, $d3, 'float')
	$return[2] = _MemoryRead($_Myoffset + 0x0AC, $d3, 'float')

	$Current_Hero_X = $return[0]
	$Current_Hero_Y = $return[1]
	$Current_Hero_Z = $return[2]

	;		Local $difmesurepos = TimerDiff($mesurepos) ;;;;;;;;;;;;;
	;_log("Mesure getcurrentpos :" & $difmesurepos) ;FOR DEBUGGING;;;;;;;;;;;;
	Return $return
EndFunc   ;==>GetCurrentPos
#ce


;;--------------------------------------------------------------------------------
;;      Approach() Approach a NPC without left clicking
;;--------------------------------------------------------------------------------
Func Approach($_x, $_y, $_z)
	; MoveToPos($_x, $_y, $_z, 0, 25)
	;While _MemoryRead($_itrInteractE + $ofs__InteractOffsetUNK2, $d3, 'int') = 1
	;	Sleep(50)
	;WEnd
EndFunc   ;==>Approach

#cs
Func IterateFilterAttack($IgnoreList)
	Local $index, $offset, $count, $item[10]
	startIterateObjectsList($index, $offset, $count)
	Dim $item_buff_2D[1][10]
	Local $i = 0

	$compt = 0

	While iterateObjectsList($index, $offset, $count, $item)
		$compt += 1
		If Is_Interact($item, $IgnoreList) Then
			If Is_Shrine($item) Or Is_Mob($item) Or Is_Loot($item) or Is_Decor_Breakable($item) or Is_Coffre($item) or Is_Power($item) or Is_Health($item) Then
				ReDim $item_buff_2D[$i + 1][10]
				For $x = 0 To 9
					$item_buff_2D[$i][$x] = $item[$x]
				Next
				$i += 1
			EndIf

		EndIf
	WEnd

	If $i = 0 Then
		Return False
	Else

		If $MonsterTri Then
			_ArraySort($item_buff_2D, 0, 0, 0, 9)
		EndIf

		If $MonsterPriority Then
			Dim $item_buff_2D_buff = TriObjectMonster($item_buff_2D)
			Dim $item_buff_2D = $item_buff_2D_buff
		EndIf
		Return $item_buff_2D
	 EndIf

EndFunc   ;==>IterateFilterAttack

Func IterateFilterZone($dist,$n=2)
	Local $index, $offset, $count, $item[10]
	startIterateObjectsList($index, $offset, $count)
;~ 	Dim $item_buff_2D[1][10]
	Local $i = 0
$my_pos_zone=getcurrentpos()
	$compt = 0

	While iterateObjectsList($index, $offset, $count, $item)
		$compt += 1
		If Is_Interact($item, "") Then
			If Is_Mob($item) and sqrt(($item[2]-$my_pos_zone[0])^2 + ($item[3]-$my_pos_zone[1])^2 ) < $dist and $item[4]<10 Then
;~ 				ReDim $item_buff_2D[$i + 1][10]
;~ 				For $x = 0 To 9
;~ 					$item_buff_2D[$i][$x] = $item[$x]
;~ 				Next
				$i += 1
			EndIf

		EndIf
	WEnd
;= 0 or ubound($item_buff_2D)
	If $i <2 Then
;~ 	   _log("pas assez de mob proche")
		Return False
	Else
;~ 		 _log("nombre : " & $i)
		return True

	EndIf
EndFunc   ;==>IterateFilterAttack
#ce


#cs
Func _log($text, $write = 0)

	$texte_write = @MDAY & "/" & @MON & "/" & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC & " | " & $text

	If $write == 1 Then
		$file = FileOpen(@ScriptDir & "\log\" & $fichierlog, 1)
		If $file = -1 Then
			_log("Log file error, cant be open")
		Else
			FileWrite($file, $texte_write & @CRLF)
		EndIf
		FileClose($file)
	EndIf

	_log(@MDAY & "/" & @MON & "/" & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC & " | " & $text)
EndFunc   ;==>_log
#ce

;;--------------------------------------------------------------------------------
;;      checkForSpell()
;;--------------------------------------------------------------------------------
#cs
Func checkForSpell()
	checkForPotion()
	;Local $mesurepot = TimerInit() ;;;;;;;;;;;;;;
	Local $source
	Local $MaximumSource
	Switch $nameCharacter
		Case "DemonHunter"
			$discipline = GetDisc()
			$hatred = GetHatred()
			$life = GetLifep()

			$diffRightClick = TimerDiff($timeforRightclick)
			If $RightClickSpell = "True" And $life <= $LifeForRightClickSpell / 100 And $diffRightClick > $RightClickSpellDelay Then
				If $RightClickSpellEnergy <> "" Then
					If $RightClickSpellEnergy = "hatred" Then
						If $hatred > $RightClickSpellEnergyNeeds / $MaximumHatred Then
							MouseClick("right")
							$timeforRightclick = TimerInit()
						EndIf
					Else
						If $discipline > $RightClickSpellEnergyNeeds / $MaximumDiscipline Then
							MouseClick("right")
							$timeforRightclick = TimerInit()
						EndIf
					EndIf
				Else
					MouseClick("right")
					$timeforRightclick = TimerInit()
				EndIf
			EndIf


			$discipline = GetDisc()
			$hatred = GetHatred()
			$life = GetLifep()

			$diffSpell1 = TimerDiff($timeforSpell1)
			If $Spell1Activated = "True" And $life <= $LifeForSpell1 / 100 And $diffSpell1 > $DefayForSpell1 Then
				If $EnergySpell1 <> "" Then
					If $EnergySpell1 = "hatred" Then
						If $hatred > $EnergyNeedsSpell1 / $MaximumHatred Then
							Send($KeyForSpell1)
							$timeforSpell1 = TimerInit()
						EndIf
					Else
						If $discipline > $EnergyNeedsSpell1 / $MaximumDiscipline Then
							Send($KeyForSpell1)
							$timeforSpell1 = TimerInit()
						EndIf
					EndIf
				Else
					Send($KeyForSpell1)
					$timeforSpell1 = TimerInit()
				EndIf
			EndIf

			$discipline = GetDisc()
			$hatred = GetHatred()
			$life = GetLifep()

			$diffSpell2 = TimerDiff($timeforSpell2)
			If $Spell2Activated = "True" And $life <= $LifeForSpell2 / 100 And $diffSpell2 > $DefayForSpell2 Then
				If $EnergySpell2 <> "" Then
					If $EnergySpell2 = "hatred" Then
						If $hatred > $EnergyNeedsSpell2 / $MaximumHatred Then
							Send($KeyForSpell2)
							$timeforSpell2 = TimerInit()
						EndIf
					Else
						If $discipline > $EnergyNeedsSpell2 / $MaximumDiscipline Then
							Send($KeyForSpell2)
							$timeforSpell2 = TimerInit()
						EndIf
					EndIf
				Else
					Send($KeyForSpell2)
					$timeforSpell2 = TimerInit()
				EndIf
			EndIf

			$discipline = GetDisc()
			$hatred = GetHatred()
			$life = GetLifep()

			$diffSpell3 = TimerDiff($timeforSpell3)
			If $Spell3Activated = "True" And $life <= $LifeForSpell3 / 100 And $diffSpell3 > $DefayForSpell3 Then
				If $EnergySpell3 <> "" Then
					If $EnergySpell3 = "hatred" Then
						If $hatred > $EnergyNeedsSpell3 / $MaximumHatred Then
							Send($KeyForSpell3)
							$timeforSpell3 = TimerInit()
						EndIf
					Else
						If $discipline > $EnergyNeedsSpell3 / $MaximumDiscipline Then
							Send($KeyForSpell3)
							$timeforSpell3 = TimerInit()
						EndIf
					EndIf
				Else
					Send($KeyForSpell3)
					$timeforSpell3 = TimerInit()
				EndIf
			EndIf

			$discipline = GetDisc()
			$hatred = GetHatred()
			$life = GetLifep()

			$diffSpell4 = TimerDiff($timeforSpell4)
			If $Spell4Activated = "True" And $life <= $LifeForSpell4 / 100 And $diffSpell4 > $DefayForSpell4 Then
				If $EnergySpell4 <> "" Then
					If $EnergySpell4 = "hatred" Then
						If $hatred > $EnergyNeedsSpell4 / $MaximumHatred Then
							Send($KeyForSpell4)
							$timeforSpell4 = TimerInit()
						EndIf
					Else
						If $discipline > $EnergyNeedsSpell4 / $MaximumDiscipline Then
							Send($KeyForSpell4)
							$timeforSpell4 = TimerInit()
						EndIf
					EndIf
				Else
					Send($KeyForSpell4)
					$timeforSpell4 = TimerInit()
				EndIf
			EndIf


		Case "Monk"
			$MaximumSource = $MaximumSpirit
			actionForSpell($MaximumSource)
		Case "Barbarian"
			$MaximumSource = $MaximumFury
			actionForSpell($MaximumSource)
		Case "wizard"
			$MaximumSource = $MaximumArcane
			actionForSpell($MaximumSource)
		Case "WitchDoctor"
			$MaximumSource = $MaximumMana
			actionForSpell($MaximumSource)
	EndSwitch

EndFunc   ;==>checkForSpell


Func actionForSpell($MaximumSource)

	$life = GetLifep()
	Switch $nameCharacter
		Case "Monk"
			$source = GetSpirit()
		Case "Barbarian"
			$source = GetFury()
		Case "wizard"
			$source = GetArcane()
		Case "WitchDoctor"
			$source = GetMana()
	EndSwitch
	$diffRightClick = TimerDiff($timeforRightclick)
	If $RightClickSpell = "True" And $life <= $LifeForRightClickSpell / 100 And $diffRightClick > $RightClickSpellDelay Then
		If $RightClickSpellEnergy <> "" Then
			If $source > $RightClickSpellEnergyNeeds / $MaximumSource Then
				MouseClick("right")
				$timeforRightclick = TimerInit()
			EndIf
		Else
			MouseClick("right")
			$timeforRightclick = TimerInit()
		EndIf
	EndIf

	$life = GetLifep()
	Switch $nameCharacter
		Case "Monk"
			$source = GetSpirit()
		Case "Barbarian"
			$source = GetFury()
		Case "wizard"
			$source = GetArcane()
		Case "WitchDoctor"
			$source = GetMana()
	EndSwitch

	$diffSpell1 = TimerDiff($timeforSpell1)
	If $Spell1Activated = "True" And $life <= $LifeForSpell1 / 100 And $diffSpell1 > $DefayForSpell1 Then
		If $EnergySpell1 <> "" Then
			If $source > $EnergyNeedsSpell1 / $MaximumSource Then
				Send($KeyForSpell1)
				$timeforSpell1 = TimerInit()
			EndIf
		Else
			Send($KeyForSpell1)
			$timeforSpell1 = TimerInit()
		EndIf
	EndIf

	$life = GetLifep()
	Switch $nameCharacter
		Case "Monk"
			$source = GetSpirit()
		Case "Barbarian"
			$source = GetFury()
		Case "wizard"
			$source = GetArcane()
		Case "WitchDoctor"
			$source = GetMana()
	EndSwitch

	$diffSpell2 = TimerDiff($timeforSpell2)
	If $Spell2Activated = "True" And $life <= $LifeForSpell2 / 100 And $diffSpell2 > $DefayForSpell2 Then
		If $EnergySpell2 <> "" Then
			If $source > $EnergyNeedsSpell2 / $MaximumSource Then
				Send($KeyForSpell2)
				$timeforSpell2 = TimerInit()
			EndIf
		Else
			Send($KeyForSpell2)
			$timeforSpell2 = TimerInit()
		EndIf
	EndIf

	$life = GetLifep()
	Switch $nameCharacter
		Case "Monk"
			$source = GetSpirit()
		Case "Barbarian"
			$source = GetFury()
		Case "wizard"
			$source = GetArcane()
		Case "WitchDoctor"
			$source = GetMana()
	EndSwitch

	$diffSpell3 = TimerDiff($timeforSpell3)
	If $Spell3Activated = "True" And $life <= $LifeForSpell3 / 100 And $diffSpell3 > $DefayForSpell3 Then
		If $EnergySpell3 <> "" Then
			If $source > $EnergyNeedsSpell3 / $MaximumSource Then
				Send($KeyForSpell3)
				$timeforSpell3 = TimerInit()
			EndIf
		Else
			Send($KeyForSpell3)
			$timeforSpell3 = TimerInit()
		EndIf
	EndIf

	$life = GetLifep()
	Switch $nameCharacter
		Case "Monk"
			$source = GetSpirit()
		Case "Barbarian"
			$source = GetFury()
		Case "wizard"
			$source = GetArcane()
		Case "WitchDoctor"
			$source = GetMana()
	EndSwitch

	$diffSpell4 = TimerDiff($timeforSpell4)
	If $Spell4Activated = "True" And $life <= $LifeForSpell4 / 100 And $diffSpell4 > $DefayForSpell4 Then
		If $EnergySpell4 <> "" Then
			If $source > $EnergyNeedsSpell4 / $MaximumSource Then
				Send($KeyForSpell4)
				$timeforSpell4 = TimerInit()
			EndIf
		Else
			Send($KeyForSpell4)
			$timeforSpell4 = TimerInit()
		EndIf
	EndIf

EndFunc   ;==>actionForSpell
#ce

#cs
Func offset_spell_search($str)
	$var = ""
	If $str = "" Then
		$var = "false"
	Else

		$var = Eval($str)
		If $var = "" Then
			$var = "wrong"
		EndIf
	EndIf
	;_log("search :" & $var)
	Return $var

EndFunc   ;==>offset_spell_search
#ce
#cs
Func FormatNumber($StringToFormat)
	Local $StringFormatted = ""
	Local $ArrayStringToFormat = StringSplit($StringToFormat, "")
	Local $counterForSeparator = 1
	For $i = $ArrayStringToFormat[0] To 1 Step -1
		If $counterForSeparator = 3 Then
			$StringFormatted = " " & $ArrayStringToFormat[$i] & $StringFormatted
			$counterForSeparator = 0
		Else
			$StringFormatted = $ArrayStringToFormat[$i] & $StringFormatted
		EndIf
		$counterForSeparator += 1
	Next
	Return $StringFormatted
EndFunc   ;==>FormatNumber
#ce
#cs
;;--------------------------------------------------------------------------------
; Function:             _format_time()
; Description:          Format time by length
;
; Note(s): faster than YoPens : 100% if < 1mn, 150% if < 1h, 30% if more
;;--------------------------------------------------------------------------------
Func _format_time($mS)
        Switch $mS
                Case 0 To 59999                 ; less than 1 mn
                        Return Round(($mS / 1000), 2) & " s"
                Case 60000 To 359999    ; 1 mn to 1 hour
                        Return Int($mS / 60000) & " mn " & Round(($mS / 1000) - Int(Int($mS / 60000) * 60)) & " s"
                Case Else                               ; more than 1 hour
                        Return Int($mS / 3600000) & "h " & Int((Int($mS / 60000) - Int(Int($mS / 3600000) * 3600) / 60)) & "mn " & Round(($mS / 1000) - Int($mS / 3600000) * 3600 - Int(Int($mS / 60000) - Int(Int($mS / 3600000) * 3600) / 60) * 60) & "s"
        EndSwitch
        Return $mS
EndFunc   ;==>_format_time
#ce